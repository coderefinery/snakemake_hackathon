<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Snakemake Hackathon documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
      <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
      <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
      <link rel="stylesheet" type="text/css" href="_static/sphinx_lesson.css" />
      <link rel="stylesheet" type="text/css" href="_static/term_role_formatting.css" />
      <link rel="stylesheet" type="text/css" href="_static/sphinx_rtd_theme_ext_color_contrast.css" />
      <link rel="stylesheet" type="text/css" href="_static/tabs.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/clipboard.min.js"></script>
        <script src="_static/copybutton.js"></script>
        <script src="_static/minipres.js"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="_static/togglebutton.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="#" class="icon icon-home">
            Snakemake Hackathon
          </a>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Materials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="#document-Snakemake_intro">Snakemake introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-Snakemake_HPC">Snakemake on the supercomputer</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-Hackathon">Hackathon</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">Snakemake Hackathon</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Snakemake Hackathon  documentation</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/coderefinery/snakemake_hackathon/blob/main/content/index" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="snakemake-hackathon">
<h1>Snakemake Hackathon<a class="headerlink" href="#snakemake-hackathon" title="Link to this heading"></a></h1>
<p>Materials for <a class="reference external" href="https://ssl.eventilla.com/snakemake_hack">Snakemake hackathon</a> organized on 22.05.24. Licensed under CC-BY-4.0 license.</p>
<a class="reference internal image-reference" href="_images/csc_geoportti_coderefinery_enccs_naiss_logos_horizontal.png"><img alt="Logos of all organizers and partners: Geoportti, CSC, CodeRefinery, ENCCS, NAISS" src="_images/csc_geoportti_coderefinery_enccs_naiss_logos_horizontal.png" style="width: 400px;" /></a>
<div class="admonition-prerequisites prerequisites admonition" id="prerequisites-0">
<p class="admonition-title">Prerequisites</p>
<ul class="simple">
<li><p>Depends on expected outcome; If needed, please read this material as supercomputing concept refresher: <a class="reference external" href="https://coderefinery.github.io/TTT4HPC_resource_management">https://coderefinery.github.io/TTT4HPC_resource_management</a>/# (If you are interested, also check the rest of the materials from “Tuesdays Tools and Techniques for HPC” (it is quite useful for daily working on clusters): <a class="reference external" href="https://scicomp.aalto.fi/training/scip/ttt4hpc-2024/">https://scicomp.aalto.fi/training/scip/ttt4hpc-2024/</a>)</p></li>
<li><p>Supercomputer access</p></li>
</ul>
</div>
<div class="toctree-wrapper compound">
<span id="document-Snakemake_intro"></span><section id="snakemake-introduction">
<h2>Snakemake introduction<a class="headerlink" href="#snakemake-introduction" title="Link to this heading"></a></h2>
<p>Snakemake is a powerful workflow management system designed to create reproducible and scalable data analyses. Originating in the bioinformatics community, Snakemake has gained widespread use in various scientific and data-intensive fields. It allows users to define workflows in a simple, readable, and maintainable way using a Python-based language. With built-in support for parallel execution and resource management, Snakemake can efficiently handle workflows on various scales, from small-scale local computations to large-scale distributed computing environments.</p>
<div class="admonition-objectives objectives admonition" id="objectives-0">
<p class="admonition-title">Objectives</p>
<ul class="simple">
<li><p>Understand the components and features of a Snakefile</p></li>
<li><p>Understand portability and reproducibility in the context of Snakemake</p></li>
<li><p>Write a snakefile</p></li>
<li><p>Run Snakemake from the shell</p></li>
<li><p>Understand the key features of Snakemake</p></li>
</ul>
</div>
<section id="what-is-a-workflow">
<h3>What is a workflow?<a class="headerlink" href="#what-is-a-workflow" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Set of computational steps</p></li>
<li><p>Step defined by input, process, output</p></li>
<li><p>Connection through input and output files</p></li>
</ul>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/workflow.png"><img alt="Example of a workflow" src="_images/workflow.png" style="width: 60%;" /></a>
</figure>
</section>
<section id="workflow-tools-and-why-we-need-them">
<h3>Workflow tools and why we need them?<a class="headerlink" href="#workflow-tools-and-why-we-need-them" title="Link to this heading"></a></h3>
<p>Imagine having some data processing workflow that takes raw data, converts and filters it, and finally produces some result, for example a plot. Each step of the workflow is done using command line tools and scripts written in different languages. You could run everything manually: step by step, checking each output and passing it to the next script or tool.</p>
<p>Soon enough, you may start automating your work. The simplest way to automate would be to use bash script (if you use MacOS/Linux). Your script may look like this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wget<span class="w"> </span>http://example.com/dataset_2024.zip
unzip<span class="w"> </span>dataset_2024.zip
python<span class="w"> </span>filter.py<span class="w"> </span>dataset_2024.txt<span class="w"> </span>filtered_dataset_2024.txt
python<span class="w"> </span>transform.py<span class="w"> </span>filtered_dataset_2024.txt<span class="w"> </span>transformed_dataset_2024.txt
Rscript<span class="w"> </span>stats.r<span class="w"> </span>filtered_dataset_2024.txt<span class="w"> </span>statistics.csv
Rscript<span class="w"> </span>plot.r<span class="w"> </span>statistics.csv<span class="w"> </span>plot.png
</pre></div>
</div>
<p>Although it works, this solution has some problems:</p>
<ul class="simple">
<li><p>How to quickly compute the results for a similar dataset from 2023?</p></li>
<li><p>How to only run the <code class="docutils literal notranslate"><span class="pre">stats.r</span></code> script for unfiltered data?</p></li>
<li><p>Have you noticed that I made a typo in the bash script and did not use transformed data for the <code class="docutils literal notranslate"><span class="pre">stats.r</span></code> script?</p></li>
<li><p>How to compute the results for all datasets available (there are 100 of them) using a computer with 20 CPU cores?</p></li>
</ul>
<p>As your workflows grow in terms of number of steps, or also the size of dataset, managing this workflow might become more and more problematic. Fortunately, over the years many solutions arose to manage and automate workflow execution. They offer plenty of features, supporting different stages of workflows: starting with the definition of a workflow, executing it and finally, gathering and sharing the results.</p>
<blockquote>
<div><p>By supporting the top layer, a workflow management system can promote the center layer, and thereby help to obtain true sustainability.</p>
</div></blockquote>
<figure class="align-default" id="id1">
<a class="reference internal image-reference" href="_images/sustainability.jpeg"><img alt="Hierarchy of aspects to consider for sustainable data analysis." src="_images/sustainability.jpeg" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-text">Image from Mölder F, Jablonski KP, Letcher B, Hall MB, Tomkins-Tinch CH, Sochat V, Forster J, Lee S, Twardziok SO, Kanitz A, Wilm A, Holtgrewe M, Rahmann S, Nahnsen S, Köster J. Sustainable data analysis with Snakemake. F1000Res. 2021 Apr 19;10:33. doi: 10.12688/f1000research.29032.2.</span><a class="headerlink" href="#id1" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="why-snakemake">
<h3>Why Snakemake?<a class="headerlink" href="#why-snakemake" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Highly popular tool: 11 new citations per week and over 1,000,000 downloads</p></li>
<li><p>Available as Python package (pip, conda), but not Python specific!</p></li>
<li><p>Python-based syntax (easy to read, quick to develop)</p></li>
<li><p>Supports multiple different scripting languages and all command line tools</p></li>
<li><p>Plenty of useful features for automating the work</p></li>
</ul>
<p>It is important to remember that Snakemake does not require Python knowledge or limits you to using Python code.</p>
<section id="installation">
<h4>Installation<a class="headerlink" href="#installation" title="Link to this heading"></a></h4>
<p>To install Snakemake on your own computer, we can use Python Package Installer (<code class="docutils literal notranslate"><span class="pre">pip</span></code>). First, ensure you have Python installed on your system.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>snakemake
</pre></div>
</div>
<p>To verify the installation, run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>snakemake<span class="w"> </span>-v
</pre></div>
</div>
<p>You should be able to see the version of Snakemake installed on your system.</p>
</section>
<section id="snakefile">
<h4>Snakefile<a class="headerlink" href="#snakefile" title="Link to this heading"></a></h4>
<p>We can define Snakemake workflows using so-called <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code>s. Workflows are defined in terms of rules. Each rule describes input files, outputs and a command or script to be run. Let’s have a look at a simple, one step workflow, that will copy the content of one file into another.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>rule<span class="w"> </span>copy:
<span class="w">    </span>input:
<span class="w">	    </span><span class="s2">&quot;hello.txt&quot;</span>
<span class="w">    </span>output:<span class="w"> </span>
<span class="w">	    </span><span class="s2">&quot;hello_copy.txt&quot;</span>
<span class="w">    </span>shell:
<span class="w">	    </span><span class="s2">&quot;cp {input} {output}&quot;</span>
</pre></div>
</div>
<p>This <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code> defines one input file <code class="docutils literal notranslate"><span class="pre">hello.txt</span></code>, one output file <code class="docutils literal notranslate"><span class="pre">hello_copy.txt</span></code> and a shell command <code class="docutils literal notranslate"><span class="pre">cp</span> <span class="pre">{input}</span> <span class="pre">{output}</span></code>. The shell command is formatted automatically by Snakemake. On runtime, <code class="docutils literal notranslate"><span class="pre">{input}</span></code> and <code class="docutils literal notranslate"><span class="pre">{output}</span></code> are substituted by the filenames provided.</p>
<p>To run this example, copy the above content into a file called <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code> (without an extension) and create a <code class="docutils literal notranslate"><span class="pre">hello.txt</span></code> file in the same folder with some content using your favorite editor or in Linux/Mac you can also do:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Hello Snakemake!&quot;</span><span class="w"> </span>&gt;<span class="w"> </span>hello.txt
</pre></div>
</div>
<p>To run the <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code>, we run the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>snakemake<span class="w"> </span>--cores<span class="w"> </span><span class="m">1</span>
</pre></div>
</div>
<p>Snakemake executes the <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code> with the one rule in it. The content is copied! Note two things: the <code class="docutils literal notranslate"><span class="pre">--cores</span></code> flag and that we did not specified the <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code>. By default, Snakemake will search for a <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code> in the current directory. We can specify which <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code> to run using the <code class="docutils literal notranslate"><span class="pre">--snakefile</span></code> flag. For example:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>snakemake<span class="w"> </span>--cores<span class="w"> </span><span class="m">1</span><span class="w"> </span>--snakefile<span class="w"> </span>Snakefile_2
</pre></div>
</div>
<p>will run the <code class="docutils literal notranslate"><span class="pre">Snakefile_2</span></code>. Thanks to that, now we can also have multiple <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code>s in one directory. The <code class="docutils literal notranslate"><span class="pre">--cores</span></code> flag tells Snakemake how many resources (cores) from our computer Snakemake can use to execute the workflow. It is a mandatory flag, so one cannot omit it. You may however also use <code class="docutils literal notranslate"><span class="pre">--jobs</span></code> instead of <code class="docutils literal notranslate"><span class="pre">--cores</span></code> which does not make a difference on a local computer.</p>
</section>
<section id="rules">
<h4>Rules<a class="headerlink" href="#rules" title="Link to this heading"></a></h4>
<p>A rule do not necessarily have to have only one input or output. If so, we can use indices to refer to each input/output value:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>rule<span class="w"> </span>sorter:
<span class="w">    </span>input:
<span class="w">        </span><span class="s2">&quot;hello.txt&quot;</span>,<span class="w"> </span>
<span class="w">        </span><span class="s2">&quot;hello2.txt&quot;</span>
<span class="w">    </span>output:
<span class="w">        </span><span class="s2">&quot;sorted_greetings.txt&quot;</span>,
<span class="w">    </span>shell:
<span class="w">        </span><span class="s2">&quot;sort {input[0]} {input[1]} &gt; {output}&quot;</span>
</pre></div>
</div>
<p>We can also use named inputs and outputs, and refer to them using their names:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>rule<span class="w"> </span>sorter:
<span class="w">    </span>input:
<span class="w">        </span><span class="nv">a</span><span class="o">=</span><span class="s2">&quot;hello.txt&quot;</span>,<span class="w"> </span>
<span class="w">        </span><span class="nv">b</span><span class="o">=</span><span class="s2">&quot;hello2.txt&quot;</span>
<span class="w">    </span>output:
<span class="w">        </span><span class="s2">&quot;sorted_greetings.txt&quot;</span>,
<span class="w">    </span>shell:
<span class="w">        </span><span class="s2">&quot;sort {input.a} {input.b} &gt; {output}&quot;</span>
</pre></div>
</div>
</section>
<section id="wildcards">
<h4>Wildcards<a class="headerlink" href="#wildcards" title="Link to this heading"></a></h4>
<p>In the examples above we used hard-coded filenames to define the input and output values. This is not feasible for most workflows dealing with more than a few files. To generalize the workflows, we can use wildcards. Wildcards are variables that replace the actual filenames or any other value, like for example a path. Snakemake resolves them automatically based on either the target file or other input/outputs in the Snakefile. Let’s add wildcards to the copy example, so it will work for any text file:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>rule<span class="w"> </span>copy:
<span class="w">    </span>input:
<span class="w">	    </span><span class="s2">&quot;{data}.txt&quot;</span>
<span class="w">    </span>output:<span class="w"> </span>
<span class="w">	    </span><span class="s2">&quot;{data}_copy.txt&quot;</span>
<span class="w">    </span>shell:
<span class="w">	    </span><span class="s2">&quot;cp {input} {output}&quot;</span>
</pre></div>
</div>
<p>To run it, we have to tell Snakemake the value of the <code class="docutils literal notranslate"><span class="pre">data</span></code> wildcard. We can do that, by specifying what kind of output /target file we want to produce. In this case, we want to have <code class="docutils literal notranslate"><span class="pre">hello_copy.txt</span></code> - the copy of the <code class="docutils literal notranslate"><span class="pre">hello.txt</span></code> file.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>snakemake<span class="w"> </span>--cores<span class="w"> </span><span class="m">1</span><span class="w"> </span>hello_copy.txt
</pre></div>
</div>
<p>Snakemake parses the <code class="docutils literal notranslate"><span class="pre">hello_copy.txt</span></code> argument and detects that the wildcard is equal to <code class="docutils literal notranslate"><span class="pre">hello</span></code>. Then, Snakemake looks for the <code class="docutils literal notranslate"><span class="pre">hello.txt</span></code> file.</p>
</section>
<section id="python-code-in-snakefile">
<h4>Python code in Snakefile<a class="headerlink" href="#python-code-in-snakefile" title="Link to this heading"></a></h4>
<p>Another powerful feature is the possibility to add Python code and function inside of Snakefile. We also have access to Python libraries, by using traditional <code class="docutils literal notranslate"><span class="pre">import</span></code> keyword. For example, the following code searches for all text files in the given directory, and appends their content in the <code class="docutils literal notranslate"><span class="pre">copy.txt</span></code> file.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>import<span class="w"> </span>os

def<span class="w"> </span>find_txt_files<span class="o">(</span>path<span class="o">)</span>:
<span class="w">    </span><span class="nv">txt_files</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span>file<span class="w"> </span><span class="k">for</span><span class="w"> </span>file<span class="w"> </span><span class="k">in</span><span class="w"> </span>os.listdir<span class="o">(</span>path<span class="o">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span>file.endswith<span class="o">(</span><span class="s2">&quot;.txt&quot;</span><span class="o">)]</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span>txt_files

rule<span class="w"> </span>append:
<span class="w">    </span>input:
<span class="w">	    </span>find_txt_files<span class="o">(</span><span class="s2">&quot;.&quot;</span><span class="o">)</span><span class="w">  </span><span class="c1"># . means the current working directory</span>
<span class="w">    </span>output:<span class="w"> </span>
<span class="w">	    </span><span class="s2">&quot;results/copy.txt&quot;</span>
<span class="w">    </span>shell:
<span class="w">	    </span><span class="s2">&quot;cat {input} &gt;&gt; {output}&quot;</span>
</pre></div>
</div>
<p>How is this different than wildcards? Here, we did not resolve or specify any filename. We can call <code class="docutils literal notranslate"><span class="pre">snakemake</span> <span class="pre">--cores</span> <span class="pre">1</span></code> without any arguments. This workflow searches for the input files by itself, without any guidance. Use with care, and for example test that the files that are found are the ones you actually want to process by doing a dry-run, using <code class="docutils literal notranslate"><span class="pre">--dry-run</span></code> when calling Snakemake.</p>
<p>Another way of using Python is replacing the shell command with Python script:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>rule<span class="w"> </span>copy:
<span class="w">    </span>input:
<span class="w">	    </span><span class="s2">&quot;hello.txt&quot;</span>
<span class="w">    </span>output:
<span class="w">        </span><span class="s2">&quot;hello_copy.txt&quot;</span>
<span class="w">    </span>run:
<span class="w">        </span>with<span class="w"> </span>open<span class="o">(</span>input<span class="o">[</span><span class="m">0</span><span class="o">])</span><span class="w"> </span>as<span class="w"> </span>in_f,<span class="w"> </span>open<span class="o">(</span>output<span class="o">[</span><span class="m">0</span><span class="o">]</span>,<span class="w"> </span><span class="s2">&quot;w&quot;</span><span class="o">)</span><span class="w"> </span>as<span class="w"> </span>out_f:
<span class="w">            </span><span class="k">for</span><span class="w"> </span>l<span class="w"> </span><span class="k">in</span><span class="w"> </span>in_f:
<span class="w">                </span>out_f.write<span class="o">(</span>l<span class="o">)</span>
</pre></div>
</div>
<p>This approach is fine for small code snippets. For bigger scripts, it is better to move code to a separate file and call it in the <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code>. Let’s create the <code class="docutils literal notranslate"><span class="pre">copy.py</span></code> file:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">snakemake</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">as</span> <span class="n">in_f</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">snakemake</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">in_f</span><span class="p">:</span>
        <span class="n">out_f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</pre></div>
</div>
<p>and modify the <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>rule<span class="w"> </span>copy:
<span class="w">    </span>input:
<span class="w">        </span><span class="s2">&quot;hello.txt&quot;</span>
<span class="w">    </span>output:
<span class="w">        </span><span class="s2">&quot;hello_copy.txt&quot;</span>
<span class="w">    </span>script:
<span class="w">        </span><span class="s2">&quot;copy.py&quot;</span>
</pre></div>
</div>
<p>In the Python file, we have access to the <code class="docutils literal notranslate"><span class="pre">snakemake</span></code> object, which allows us to get access to the content of the <code class="docutils literal notranslate"><span class="pre">input</span></code> and <code class="docutils literal notranslate"><span class="pre">output</span></code> directives! We do not need to parse any command line arguments. The access is granted by the <code class="docutils literal notranslate"><span class="pre">script</span></code> keyword, which works like a wrapper around the script. Similar integrations are available for other languages as well: R, Markdown, Julia, Rust, Bash and Jupyter Notebook. See the current list in the <a class="reference external" href="https://snakemake.readthedocs.io/en/stable/snakefiles/rules.html#external-scripts">Snakemake documentation</a>.</p>
</section>
<section id="dependencies-between-rules">
<h4>Dependencies between rules<a class="headerlink" href="#dependencies-between-rules" title="Link to this heading"></a></h4>
<p>So far, we only examined <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code>s with only one rule. Let’s have a look at a bigger workflow.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>rule<span class="w"> </span>concatenate:
<span class="w">    </span>input:
<span class="w">        </span>expand<span class="o">(</span><span class="s2">&quot;data/file{n}.txt&quot;</span>,<span class="w"> </span><span class="nv">n</span><span class="o">=[</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span><span class="o">])</span>
<span class="w">    </span>output:
<span class="w">        </span><span class="s2">&quot;results/concatenated.txt&quot;</span>
<span class="w">    </span>shell:
<span class="w">        </span><span class="s2">&quot;cat {input} &gt; {output}&quot;</span>

rule<span class="w"> </span>count_words:
<span class="w">    </span>input:
<span class="w">        </span><span class="s2">&quot;results/concatenated.txt&quot;</span>
<span class="w">    </span>output:
<span class="w">        </span><span class="s2">&quot;results/word_count.txt&quot;</span>
<span class="w">    </span>shell:
<span class="w">        </span><span class="s2">&quot;wc -w {input} &gt; {output}&quot;</span>
</pre></div>
</div>
<p>This workflow concatenates three input files (<code class="docutils literal notranslate"><span class="pre">data/file1.txt</span></code>, <code class="docutils literal notranslate"><span class="pre">data/file2.txt</span></code>, <code class="docutils literal notranslate"><span class="pre">data/file3.txt</span></code> using <code class="docutils literal notranslate"><span class="pre">expand</span></code>, another way to define e.g. filenames more specific than wildcards) and then counts how many words there are in the files using the command line tool <code class="docutils literal notranslate"><span class="pre">wc</span></code>. The <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code> consists of three rules. The dependencies between rules are set by the input and output filenames. The rule <code class="docutils literal notranslate"><span class="pre">concatenate</span></code> generates the output file: <code class="docutils literal notranslate"><span class="pre">results/concatenated.txt</span></code>, which then is used as an input to the <code class="docutils literal notranslate"><span class="pre">count_words</span></code> rule.</p>
<p>Snakemake uses top-down approach to automatically resolve the dependencies between rules. That means, Snakemake will start from the last rule (so-called <code class="docutils literal notranslate"><span class="pre">target</span> <span class="pre">rule</span></code>) and go backwards, searching for the input needed to execute that step. By default, the target rule is the first rule in the Snakefile. In this case, we want to run the <code class="docutils literal notranslate"><span class="pre">count_words</span></code> rule as the target (first we concatenate, then we count the words). We have to somehow tell Snakemake what is the final output of this workflow. To achieve that, a common practice is adding a mock <code class="docutils literal notranslate"><span class="pre">rule</span> <span class="pre">all</span></code> at the beginning of the <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code> that encapsulates the final outputs of the workflow:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>rule<span class="w"> </span>all:
<span class="w">    </span>input:
<span class="w">        </span><span class="s2">&quot;results/word_count.txt&quot;</span>

rule<span class="w"> </span>concatenate:
<span class="w">    </span>input:
<span class="w">        </span>expand<span class="o">(</span><span class="s2">&quot;data/file{n}.txt&quot;</span>,<span class="w"> </span><span class="nv">n</span><span class="o">=[</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span><span class="o">])</span>
<span class="w">    </span>output:
<span class="w">        </span><span class="s2">&quot;results/concatenated.txt&quot;</span>
<span class="w">    </span>shell:
<span class="w">        </span><span class="s2">&quot;cat {input} &gt; {output}&quot;</span>

rule<span class="w"> </span>count_words:
<span class="w">    </span>input:
<span class="w">        </span><span class="s2">&quot;results/concatenated.txt&quot;</span>
<span class="w">    </span>output:
<span class="w">        </span><span class="s2">&quot;results/word_count.txt&quot;</span>
<span class="w">    </span>shell:
<span class="w">        </span><span class="s2">&quot;wc -w {input} &gt; {output}&quot;</span>
</pre></div>
</div>
<p>Snakemake will see that we want the <code class="docutils literal notranslate"><span class="pre">results/word_count.txt</span></code> file, and will search in the <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code> to see what rule produces this exact output. Then, it will repeat this process recursively until all dependencies are resolved. By doing so, a so-called directed acyclic graph (DAG) is created. It is a step-by-step execution plan for Snakemake. We can see and analyze this graph by calling Snakemake with <code class="docutils literal notranslate"><span class="pre">--dag</span></code> flag:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>snakemake<span class="w"> </span>--cores<span class="w"> </span><span class="m">1</span><span class="w"> </span>--dag
</pre></div>
</div>
<p>The result can be visualized using either the <code class="docutils literal notranslate"><span class="pre">GraphViz</span></code> package (which needs to be installed separately, see example call below), or using <a class="reference external" href="https://dreampuf.github.io/GraphvizOnline/">GraphVizOnline</a>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>snakemake<span class="w"> </span>--cores<span class="w"> </span><span class="m">1</span><span class="w"> </span>--dag<span class="w"> </span><span class="p">|</span><span class="w"> </span>dot<span class="w"> </span>-Tpng<span class="w"> </span>&gt;<span class="w"> </span>dag.png
</pre></div>
</div>
<p>Another way to link rules in the <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code> would be to directly refer to the outputs of the rules by using the rule’s name. This approach is more robust when the execution order of the steps matters, as we can freely adjust output names, without breaking the workflow. Remember that you can only refer to the rules that were defined before, so the <code class="docutils literal notranslate"><span class="pre">all</span></code> rule cannot be modified that way!</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>rule<span class="w"> </span>all:
<span class="w">    </span>input:
<span class="w">        </span><span class="s2">&quot;results/word_count.txt&quot;</span>

rule<span class="w"> </span>concatenate:
<span class="w">    </span>input:
<span class="w">        </span>expand<span class="o">(</span><span class="s2">&quot;data/file{n}.txt&quot;</span>,<span class="w"> </span><span class="nv">n</span><span class="o">=[</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span><span class="o">])</span>
<span class="w">    </span>output:
<span class="w">        </span><span class="s2">&quot;results/concatenated.txt&quot;</span>
<span class="w">    </span>shell:
<span class="w">        </span><span class="s2">&quot;cat {input} &gt; {output}&quot;</span>

rule<span class="w"> </span>count_words:
<span class="w">    </span>input:
<span class="w">        </span>rules.concatenate.output
<span class="w">    </span>output:
<span class="w">        </span><span class="s2">&quot;results/word_count.txt&quot;</span>
<span class="w">    </span>shell:
<span class="w">        </span><span class="s2">&quot;wc -w {input} &gt; {output}&quot;</span>
</pre></div>
</div>
</section>
<section id="force-execution">
<h4>Force execution<a class="headerlink" href="#force-execution" title="Link to this heading"></a></h4>
<p>Snakemake is designed to efficiently manage the execution of complex workflows by only computing the parts that are necessary. Specifically, it checks the presence and timestamps from the metadata of the output files specified in your workflow rules. If an output file already exists and is up to date, Snakemake will skip the computation steps that produce that file, saving time and resources by avoiding redundant computations.</p>
<p>However, there are situations where you might want to recompute the entire workflow, regardless of the existing files. In such cases, you can force Snakemake to recompute all the steps by using the <code class="docutils literal notranslate"><span class="pre">-F</span></code> or <code class="docutils literal notranslate"><span class="pre">--forceall</span></code> flag. This tells Snakemake to ignore the existing output files and re-run all the rules as if the files were missing.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>snakemake<span class="w"> </span>--cores<span class="w"> </span><span class="m">1</span><span class="w"> </span>--forceall
</pre></div>
</div>
<p>Besides forced execution, Snakemake may execute a rule again in two more cases: if the rule definition has changed since the last execution (for example by adding a new output file) or if the script that is executed has changed (only when using the <code class="docutils literal notranslate"><span class="pre">script</span></code> keyword).</p>
</section>
<section id="parallelization">
<h4>Parallelization<a class="headerlink" href="#parallelization" title="Link to this heading"></a></h4>
<p>So far, we only used Snakemake with one core (<code class="docutils literal notranslate"><span class="pre">--cores</span> <span class="pre">1</span></code>). Let’s say we have a workflow that processes four files. Each file is processed with two steps: <code class="docutils literal notranslate"><span class="pre">modify_file</span></code> and <code class="docutils literal notranslate"><span class="pre">count_words</span></code>.</p>
<p>The rule <code class="docutils literal notranslate"><span class="pre">modify_file</span></code> copies the content of the input file to the outputfile using <code class="docutils literal notranslate"><span class="pre">cat</span></code> and redirection <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, then appends the content of the params directive to the output file using <code class="docutils literal notranslate"><span class="pre">echo</span></code> and redirect append <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>. In the end the process pauses for 5 seconds using <code class="docutils literal notranslate"><span class="pre">sleep</span> <span class="pre">5</span></code>.</p>
<p>The rule <code class="docutils literal notranslate"><span class="pre">count_words</span></code> uses the command line tool <code class="docutils literal notranslate"><span class="pre">wc</span></code> with the argument <code class="docutils literal notranslate"><span class="pre">-w</span></code> to count the number of words in the input file and writes the number to the output file. In the end the process pauses for 5 seconds using <code class="docutils literal notranslate"><span class="pre">sleep</span> <span class="pre">5</span></code>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>rule<span class="w"> </span>all:
<span class="w">    </span>input:
<span class="w">        </span><span class="s2">&quot;results/word_count_file1.txt&quot;</span>,
<span class="w">        </span><span class="s2">&quot;results/word_count_file2.txt&quot;</span>,
<span class="w">        </span><span class="s2">&quot;results/word_count_file3.txt&quot;</span>,
<span class="w">        </span><span class="s2">&quot;results/word_count_file4.txt&quot;</span>,

rule<span class="w"> </span>modify_file:
<span class="w">    </span>params:
<span class="w">        </span><span class="nv">msg</span><span class="o">=</span><span class="s2">&quot;This was modified by Snakemake!&quot;</span>
<span class="w">    </span>input:
<span class="w">        </span><span class="s2">&quot;data/{file}.txt&quot;</span>
<span class="w">    </span>output:
<span class="w">        </span><span class="s2">&quot;results/modified_{file}.txt&quot;</span>,
<span class="w">    </span>shell:
<span class="w">        </span><span class="s2">&quot;cat {input} &gt; {output} &amp;&amp; echo &#39;{params.msg}&#39; &gt;&gt; {output}  &amp;&amp; sleep 5&quot;</span>

rule<span class="w"> </span>count_words:
<span class="w">    </span>input:
<span class="w">        </span><span class="s2">&quot;results/modified_{file}.txt&quot;</span>,
<span class="w">    </span>output:
<span class="w">        </span><span class="s2">&quot;results/word_count_{file}.txt&quot;</span>,
<span class="w">    </span>shell:
<span class="w">        </span><span class="s2">&quot;wc -w {input} &gt; {output} &amp;&amp; sleep 5&quot;</span>
</pre></div>
</div>
<p>When we create a DAG for that workflow, we see that there are four branches in the graph - one for each file.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/parallel_workflow.png"><img alt="_images/parallel_workflow.png" src="_images/parallel_workflow.png" style="width: 60%;" /></a>
</figure>
<p>If we run Snakemake with the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>snakemake<span class="w"> </span>--cores<span class="w"> </span><span class="m">1</span>
</pre></div>
</div>
<p>The execution will take a little bit more than 40 seconds. Snakemake uses only one core, executing one job at a time. Let’s increase number of cores to 2. To run the full workflow again, even though the files have already been processed, remember to add the <code class="docutils literal notranslate"><span class="pre">--forceall</span></code> flag.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>snakemake<span class="w"> </span>--cores<span class="w"> </span><span class="m">2</span><span class="w"> </span>--forceall
</pre></div>
</div>
<p>Now we can see in the terminal output, that Snakemake is running two jobs at a time, using two cores. The execution time was around two times faster. Snakemake automatically detected, that some parts of the workflow can be run in parallel, and used the provided resources to parallelize the work. In this case, each file can be processed independently, there is no aggregation or combining the results.</p>
</section>
<section id="error-recovery-and-re-entry">
<h4>Error recovery and re-entry<a class="headerlink" href="#error-recovery-and-re-entry" title="Link to this heading"></a></h4>
<p>Snakemake offers error recovery features. Analyzing the above example, what would happen if one of the input files that we try to modify is corrupted, i.e. not readable? Snakemake will automatically stop the execution of the entire workflow, even though three other files can be processed correctly. Although this behaviour may be useful in some cases, sometimes we may want to compute as many results as we can. To enable this, we can use the <code class="docutils literal notranslate"><span class="pre">--keep-going</span></code> flag. It makes Snakemake keep going as far into workflow as it possibly can, computing all results that do not rely on corrupted files or failed jobs.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>snakemake<span class="w"> </span>--cores<span class="w"> </span><span class="m">2</span><span class="w"> </span>--keep-going
</pre></div>
</div>
<p>Another error recovery strategy is retrying, which is useful for example when your workflow relies on some online resource.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>rule<span class="w"> </span>get_data_from_server:
<span class="w">    </span>output:
<span class="w">        </span><span class="s2">&quot;test.txt&quot;</span>
<span class="w">    </span>retries:<span class="w"> </span><span class="m">3</span>
<span class="w">    </span>shell:
<span class="w">        </span><span class="s2">&quot;curl https://some.unreliable.server/test.txt &gt; {output}&quot;</span>
</pre></div>
</div>
<p>In cases where a server does not respond with any data, the <code class="docutils literal notranslate"><span class="pre">curl</span></code> command exists with an error. Snakemake quickly retries the job three times. Retrying can be set globally for all jobs using the <code class="docutils literal notranslate"><span class="pre">--retries</span></code> flag followed by the number of retries.</p>
</section>
</section>
<section id="reporting">
<h3>Reporting<a class="headerlink" href="#reporting" title="Link to this heading"></a></h3>
<p>Snakemake generates execution logs with the content that is also printed in the terminal and stores them in the (hidden) <code class="docutils literal notranslate"><span class="pre">.snakemake</span></code> directory located in the directory where the <code class="docutils literal notranslate"><span class="pre">snakemake</span></code> command is executed . After executing a workflow, Snakemake saves metadata about the execution in that directory. To generate a proper report, we use the <code class="docutils literal notranslate"><span class="pre">--report</span></code> flag when executing the <code class="docutils literal notranslate"><span class="pre">snakemake</span></code> command followed by the filename for the report.</p>
<p>Reports in Snakemake are <code class="docutils literal notranslate"><span class="pre">html</span></code> documents that are generated after workflow execution. They summarize the work done by Snakemake together with some statistics. To generate <code class="docutils literal notranslate"><span class="pre">html</span></code> reports, an extra Python package called <code class="docutils literal notranslate"><span class="pre">pygments</span></code> needs to be installed, for example using <code class="docutils literal notranslate"><span class="pre">pip</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>pygments
</pre></div>
</div>
<p>Let’s see how we can generate a report. For that, we can use one of the previous workflows.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>rule<span class="w"> </span>all:
<span class="w">    </span>input:
<span class="w">        </span><span class="s2">&quot;results/word_count.txt&quot;</span>

rule<span class="w"> </span>concatenate:
<span class="w">    </span>input:
<span class="w">        </span>expand<span class="o">(</span><span class="s2">&quot;data/file{n}.txt&quot;</span>,<span class="w"> </span><span class="nv">n</span><span class="o">=[</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span><span class="o">])</span>
<span class="w">    </span>output:
<span class="w">        </span><span class="s2">&quot;results/concatenated.txt&quot;</span>
<span class="w">    </span>shell:
<span class="w">        </span><span class="s2">&quot;cat {input} &gt; {output}&quot;</span>

rule<span class="w"> </span>count_words:
<span class="w">    </span>input:
<span class="w">        </span><span class="s2">&quot;results/concatenated.txt&quot;</span>
<span class="w">    </span>output:
<span class="w">        </span><span class="s2">&quot;results/word_count.txt&quot;</span>
<span class="w">    </span>shell:
<span class="w">        </span><span class="s2">&quot;wc -w {input} &gt; {output}&quot;</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>snakemake<span class="w"> </span>--report<span class="w"> </span>report.html
</pre></div>
</div>
<p>We can add more information to the report, including the output data of our workflow. In such cases, data is added to the HTML document and can be downloaded. This way we can share the results (at least if they are quite small) with the report and execution information!</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>rule<span class="w"> </span>all:
<span class="w">    </span>input:
<span class="w">        </span><span class="s2">&quot;results/word_count.txt&quot;</span>

rule<span class="w"> </span>concatenate:
<span class="w">    </span>input:
<span class="w">        </span>expand<span class="o">(</span><span class="s2">&quot;data/file{n}.txt&quot;</span>,<span class="w"> </span><span class="nv">n</span><span class="o">=[</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span><span class="o">])</span>
<span class="w">    </span>output:
<span class="w">        </span>report<span class="o">(</span>
<span class="w">            </span><span class="s2">&quot;results/concatenated.txt&quot;</span>,
<span class="w">            </span><span class="nv">category</span><span class="o">=</span><span class="s2">&quot;Step 1&quot;</span>
<span class="w">        </span><span class="o">)</span>
<span class="w">    </span>shell:
<span class="w">        </span><span class="s2">&quot;cat {input} &gt; {output}&quot;</span>

rule<span class="w"> </span>count_words:
<span class="w">    </span>input:
<span class="w">        </span><span class="s2">&quot;results/concatenated.txt&quot;</span>
<span class="w">    </span>output:
<span class="w">        </span>report<span class="o">(</span>
<span class="w">            </span><span class="s2">&quot;results/word_count.txt&quot;</span>,
<span class="w">            </span><span class="nv">category</span><span class="o">=</span><span class="s2">&quot;Step 2&quot;</span>
<span class="w">        </span><span class="o">)</span>
<span class="w">    </span>shell:
<span class="w">        </span><span class="s2">&quot;wc -w {input} &gt; {output}&quot;</span>
</pre></div>
</div>
<p>By adding the <code class="docutils literal notranslate"><span class="pre">report()</span></code> around our output files, we include both output text files in the report. When opening the report in a web browser, we can now also access the output files and download them.</p>
</section>
<section id="monitoring">
<h3>Monitoring<a class="headerlink" href="#monitoring" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Warning: this section may not work for Windows users!</p>
</div></blockquote>
<p>Snakemake also offers an option for monitoring the workflow from outside of the current workflow execution using an extra tool called <code class="docutils literal notranslate"><span class="pre">panoptes</span></code>. It provides a simple web page with an API to which Snakemake connects. For Linux and Mac, <code class="docutils literal notranslate"><span class="pre">panoptes</span></code> can be installed using <code class="docutils literal notranslate"><span class="pre">pip</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>panoptes-ui
</pre></div>
</div>
<p>Panoptes will run a server on <code class="docutils literal notranslate"><span class="pre">localhost</span></code> (i.e. on our computer), which we can start using the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>panoptes
</pre></div>
</div>
<p>To close the server, we can use <code class="docutils literal notranslate"><span class="pre">CTRL+C</span></code> in the terminal. The server is running by default on <code class="docutils literal notranslate"><span class="pre">http://127.0.0.1:5000</span></code>. If we open our browser and visit this website, we will see the graphical interface for monitoring workflows. Note that now we cannot use our terminal, because it is used by <code class="docutils literal notranslate"><span class="pre">panoptes</span></code>. We have to open a new one to be able to run new commands. To connect Snakemake to the monitoring, we modify our <code class="docutils literal notranslate"><span class="pre">snakemake</span></code> command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>snakemake<span class="w"> </span>--cores<span class="w"> </span><span class="m">1</span><span class="w"> </span>--wms-monitor<span class="w"> </span>http://127.0.0.1:5000
</pre></div>
</div>
<p>If you server has a different URL, replace it in the command above. When we execute the workflow, we can see some basic statistics about the execution.</p>
<p>Warning: this set-up might be not secure enough for the production use. See <a class="reference external" href="https://github.com/panoptes-organization/panoptes/issues/172">this thread</a> for more details.</p>
</section>
<section id="workflow-reproducibility">
<h3>Workflow reproducibility<a class="headerlink" href="#workflow-reproducibility" title="Link to this heading"></a></h3>
<p>Reproducibility in computational workflows ensures that an analysis can be consistently repeated with the same results, which is crucial for validating findings, ensuring transparency, and facilitating collaboration. It allows other researchers to verify results, understand methodologies, and build upon previous work.</p>
<section id="project-structure">
<h4>Project structure<a class="headerlink" href="#project-structure" title="Link to this heading"></a></h4>
<p>Snakemake provides recommendations regarding project structure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>├── .gitignore
├── README.md
├── LICENSE.md
├── workflow
│   ├── rules
|   │   ├── module1.smk
|   │   └── module2.smk
│   ├── envs
|   │   ├── tool1.yaml
|   │   └── tool2.yaml
│   ├── scripts
|   │   ├── script1.py
|   │   └── script2.R
│   ├── notebooks
|   │   ├── notebook1.py.ipynb
|   │   └── notebook2.r.ipynb
│   ├── report
|   │   ├── plot1.rst
|   │   └── plot2.rst
|   └── Snakefile
├── config
│   ├── config.yaml
│   └── some-sheet.tsv
├── results
└── resources
</pre></div>
</div>
<p>Following the <a class="reference external" href="https://snakemake.readthedocs.io/en/stable/snakefiles/deployment.html#distribution-and-reproducibility">documentation</a>:</p>
<blockquote>
<div><p>The workflow code goes into a subdirectory called <code class="docutils literal notranslate"><span class="pre">workflow</span></code>, while the configuration is stored in a subdirectory called <code class="docutils literal notranslate"><span class="pre">config</span></code>. Inside of the <code class="docutils literal notranslate"><span class="pre">workflow</span></code> subdirectory, the central <code class="docutils literal notranslate"><span class="pre">Snakefile</span></code> marks the entrypoint of the workflow (it will be automatically discovered when running snakemake from the root of above structure).</p>
</div></blockquote>
<blockquote>
<div><p>Workflows that are set up in above structure can be more easily re-used and combined via the <a class="reference external" href="https://snakemake.readthedocs.io/en/stable/snakefiles/deployment.html#use-with-modules">Snakemake module system</a>. Such deployment can even be automated via <a class="reference external" href="https://snakedeploy.readthedocs.io/en/latest/">Snakedeploy</a>. Moreover, by publishing a workflow on Github and following a set of additional rules the workflow will be automatically included in the <a class="reference external" href="https://snakemake.github.io/snakemake-workflow-catalog/">Snakemake workflow catalog</a>, thereby easing discovery and even automating its usage documentation.</p>
</div></blockquote>
</section>
<section id="containerization">
<h4>Containerization<a class="headerlink" href="#containerization" title="Link to this heading"></a></h4>
<p>Containers, like Docker or Singularity/Apptainer, provide a lightweight and portable way to package and run applications. They encapsulate an application and its dependencies, ensuring it runs consistently across different environments. Unlike virtual machines, containers share the host system’s kernel but isolate the application’s processes, filesystem, and resources. This makes containers more efficient in terms of performance and resource usage, allowing for quick startup times and easier scalability.</p>
<p>To use containers with Snakemake, we add the <code class="docutils literal notranslate"><span class="pre">container</span></code> keyword inside a rule, linking either to a local or external container image:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>shell.executable<span class="o">(</span><span class="s2">&quot;/bin/sh&quot;</span><span class="o">)</span>

rule<span class="w"> </span>copy:
<span class="w">    </span>container:
<span class="w">        </span><span class="s2">&quot;docker://alpine:3.14&quot;</span>
<span class="w">    </span>input:
<span class="w">	    </span><span class="s2">&quot;hello.txt&quot;</span>
<span class="w">    </span>output:<span class="w"> </span>
<span class="w">	    </span><span class="s2">&quot;hello_copy.txt&quot;</span>
<span class="w">    </span>shell:
<span class="w">	    </span><span class="s2">&quot;cp {input} {output}&quot;</span>
</pre></div>
</div>
<p>Note that in this case we also have to define the shell executable available within the alpine container with <code class="docutils literal notranslate"><span class="pre">shell.executable(&quot;/bin/sh&quot;)</span></code>.</p>
<p>To execute that Snakefile, we have to add the <code class="docutils literal notranslate"><span class="pre">--software-deployment-method</span></code> flag:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>snakemake<span class="w"> </span>--cores<span class="w"> </span><span class="m">1</span><span class="w"> </span>--software-deployment-method<span class="w"> </span>apptainer
</pre></div>
</div>
<p>When executed, Snakemake will run the <code class="docutils literal notranslate"><span class="pre">copy</span></code> job inside the <code class="docutils literal notranslate"><span class="pre">Alpine</span></code> (one of the Linux operating systems) image. Note that running that code requires the <code class="docutils literal notranslate"><span class="pre">apptainer</span></code> command to be available on your system.</p>
</section>
</section>
<section id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Link to this heading"></a></h3>
<p>Presented features are only a subset of all things that Snakemake has to offer. Feel free to check the <a class="reference external" href="https://snakemake.github.io">official documentation</a> for the latest updates! There are also tutorials that cover most of the basics.</p>
<p>Snakemake offers plenty of features that automate the process of creating, running and overseeing the execution. You can document your workflow using DAG and reports. It is easier to make better usage of resources thanks to the implicit parallelization. Error recovery helps with dealing with errors, which are inevitable.</p>
<p>So far, we only used a personal computer. In that mode, Snakemake is using a so-called <code class="docutils literal notranslate"><span class="pre">local</span> <span class="pre">executor</span></code>, which uses resources of our computer. After a short break, you will learn how to use other types of executors, that allow for integrating with supercomputers and leveraging resources that they offer.</p>
</section>
</section>
<span id="document-Snakemake_HPC"></span><section id="snakemake-on-the-supercomputer">
<h2>Snakemake on the supercomputer<a class="headerlink" href="#snakemake-on-the-supercomputer" title="Link to this heading"></a></h2>
<div class="admonition-objectives objectives admonition" id="objectives-0">
<p class="admonition-title">Objectives</p>
<ul class="simple">
<li><p>Understand the different ways Snakemake can be run on clusters</p></li>
<li><p>Evaluate which way suits your needs</p></li>
<li><p>Get an idea on how to make own workflow ready for the supercomputer</p></li>
</ul>
</div>
<blockquote>
<div><p>Note on versions: These materials assume Snakemake version 8.0 or later. Earlier (before version 8.0) Snakemake versions deal differently with SLURM. Please check the documentation for your version of snakemake.</p>
</div></blockquote>
<section id="cluster-snakemake-installation">
<h3>Cluster Snakemake installation<a class="headerlink" href="#cluster-snakemake-installation" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p>Preinstalled and made available via module: <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">load</span> <span class="pre">snakemake/version</span></code></p></li>
<li><p>Own Conda/Pip based installation</p></li>
<li><p>Own container based installation</p></li>
</ol>
<p>Always check first if your cluster has the tool available as <strong>module</strong>, then you do not have to worry about installation yourself.
If you need additional packages, you can usually add own packages by <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span></code> for your own user or project. It may also be possible to load multiple modules at the same time (feasibility depends on the modules). If that for some reason does not work, you can create your own installation with Conda or Pip, or by making use of containers. <strong>Check your clusters documentation for information on how to do these.</strong>
Ask your friendly cluster support for help or advice, if needed.</p>
</section>
<section id="ways-of-running-snakemake-on-clusters">
<h3>Ways of running Snakemake on clusters<a class="headerlink" href="#ways-of-running-snakemake-on-clusters" title="Link to this heading"></a></h3>
<section id="within-one-slurm-job">
<h4>Within one SLURM job<a class="headerlink" href="#within-one-slurm-job" title="Link to this heading"></a></h4>
<section id="interactive">
<h5>Interactive<a class="headerlink" href="#interactive" title="Link to this heading"></a></h5>
<p>You can run snakemake the same way you would run it on your own computer also on cluster within one interactive or normal batch job (one resource allocation for the whole workflow (= all rules)). The interactive session is is a useful first step to try it out, but does not scale well (only to the resource limits of one interactive job).</p>
<p>In an interactive job (using the interactive partition; some clusters support starting an interactive session with the <code class="docutils literal notranslate"><span class="pre">sinteractive</span></code> command), you would load the snakemake module, and then run <code class="docutils literal notranslate"><span class="pre">snakemake</span> <span class="pre">--cores</span> <span class="pre">1</span></code> (or more, if you reserved more) as you would on your local machine.</p>
<p>You can run snakemake in the background for example with <a class="reference external" href="https://linux.die.net/man/1/screen"><code class="docutils literal notranslate"><span class="pre">screen</span></code></a>.</p>
<section id="sbatch-script">
<h6>Sbatch script<a class="headerlink" href="#sbatch-script" title="Link to this heading"></a></h6>
<p>Another way to run snakemake in <strong>one job</strong> is to use an sbatch script for job submission to run the workflow non-interactive.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1">#SBATCH --job-name=myTest</span>
<span class="c1">#SBATCH --account=project_xxxxx</span>
<span class="c1">#SBATCH --time=00:10:00</span>
<span class="c1">#SBATCH --mem-per-cpu=2G</span>
<span class="c1">#SBATCH --partition=test</span>
<span class="c1">#SBATCH --cpus-per-task=4</span>

<span class="n">module</span> <span class="n">load</span> <span class="n">snakemake</span><span class="o">/</span><span class="n">version</span>
<span class="n">snakemake</span> <span class="o">--</span><span class="n">cores</span> <span class="mi">4</span>
</pre></div>
</div>
<p>Note how 4 CPUs are reserved ( <code class="docutils literal notranslate"><span class="pre">#SBATCH</span> <span class="pre">--cpus-per-task=4</span></code>) and made available to the workflow (<code class="docutils literal notranslate"><span class="pre">--cores</span> <span class="pre">4</span></code>). Within the Snakefile resource distribution and parallelization can be controlled using <code class="docutils literal notranslate"><span class="pre">threads:X</span></code> directive, see the <a class="reference external" href="https://snakemake.readthedocs.io/en/stable/snakefiles/rules.html#threads">Snakemake documentation on threads</a>.</p>
</section>
</section>
<section id="slurm-integration-with-the-snakemake-slurm-executor-plugin">
<h5>Slurm integration with the <a class="reference external" href="https://snakemake.github.io/snakemake-plugin-catalog/plugins/executor/slurm.html">Snakemake SLURM executor plugin</a><a class="headerlink" href="#slurm-integration-with-the-snakemake-slurm-executor-plugin" title="Link to this heading"></a></h5>
<p>With the plugin you can define SLURM batch job resources for your snakemake workflow instead of writing an sbatch file.</p>
<p>Snakemake provides a <a class="reference external" href="https://snakemake.github.io/snakemake-plugin-catalog/plugins/executor/slurm.html">Snakemake SLURM executor</a> as plugin, which can be used to let Snakemake run workflows on clusters. For this, you would start an interactive session, from which you could call :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">load</span> <span class="n">snakemake</span><span class="o">/</span><span class="n">version</span>

<span class="n">snakemake</span> <span class="o">--</span><span class="n">jobs</span> <span class="mi">1</span> <span class="o">--</span><span class="n">executor</span> <span class="n">slurm</span> <span class="o">--</span><span class="n">default</span><span class="o">-</span><span class="n">resources</span> <span class="n">slurm_account</span><span class="o">=</span><span class="n">project_xxx</span> <span class="n">slurm_partition</span><span class="o">=</span><span class="n">test</span> <span class="n">runtime</span><span class="o">=</span><span class="mi">10</span> <span class="n">mem_mb_per_cpu</span><span class="o">=</span><span class="mi">2000</span> <span class="n">cpus_per_task</span><span class="o">=</span><span class="mi">4</span>
</pre></div>
</div>
<p>This command would submit <strong>one new job</strong> (defined by <code class="docutils literal notranslate"><span class="pre">--jobs</span> <span class="pre">1</span></code>) to SLURM for running the whole workflow in that job, similar to the sbatch script above. Instead of defining <code class="docutils literal notranslate"><span class="pre">cpus_per_task</span></code> for the whole workflow, one could also define <code class="docutils literal notranslate"><span class="pre">threads:X</span></code> for each rule.</p>
<p>Other SLURM resource specifications can be found from the table in the <a class="reference external" href="https://snakemake.github.io/snakemake-plugin-catalog/plugins/executor/slurm.html#advanced-resource-specifications">SLURM executor plugin documentation</a>.</p>
<p>The SLURM integration also provides the possibility to start multiple SLURM jobs (specified by setting <code class="docutils literal notranslate"><span class="pre">--jobs</span></code> to &gt; 1) for you; for example one for each step. However, with this option you would have to wait in queue for every single step to be executed which generates a lot of overhead, especially for short job steps. Using the Snakemake SLURM integration this way should therefore be avoided in cases where single steps are short. A better solution to scale up your Snakemake workflow (also to multiple nodes) is to use Hyperqueue instead:</p>
</section>
</section>
<section id="snakemake-at-scale-using-hyperqueue">
<h4>Snakemake at scale using Hyperqueue<a class="headerlink" href="#snakemake-at-scale-using-hyperqueue" title="Link to this heading"></a></h4>
<p><a class="reference external" href="https://it4innovations.github.io/hyperqueue/stable/">HyperQueue (HQ)</a> is an efficient sub-node task scheduler. Instead of submitting each of your computational tasks as separate Slurm jobs or job steps, you can allocate a large resource block and then use HyperQueue to submit your tasks to this allocation, even when running your workflow on multiple nodes.
The <a class="reference external" href="https://snakemake.github.io/snakemake-plugin-catalog/plugins/executor/cluster-generic.html">generic cluster executor</a> plugin can be used to configure hyperqueue runs, e.g. <code class="docutils literal notranslate"><span class="pre">snakemake</span> <span class="pre">--executor</span> <span class="pre">cluster-generic</span> <span class="pre">--cluster-generic-submit-cmd</span> <span class="pre">&quot;hq</span> <span class="pre">submit</span> <span class="pre">...&quot;</span> </code>.</p>
<ul class="simple">
<li><p>Useful for high-throughput jobs (many steps and rules on many files, needing a lot of resources)</p></li>
<li><p>Extra benefit: Multiple nodes can be used under the same job allocation</p></li>
</ul>
<p>For more information, please check out the provided Hyperqueue example.</p>
</section>
</section>
<section id="config-profile-files">
<h3>Config/Profile files<a class="headerlink" href="#config-profile-files" title="Link to this heading"></a></h3>
<p>Snakemake takes many parameters as command line arguments/flags. However, when working with clusters these can become quite many very fast. Many of which also do not change very often, e.g. <code class="docutils literal notranslate"><span class="pre">slurm-account</span></code>. One way to make the command line call shorter, is to define some of the parameters in <a class="reference external" href="https://snakemake.readthedocs.io/en/stable/executing/cli.html#profiles"><strong>profiles</strong></a>. These can be global or workflow specific.</p>
<p>A profile is written in <code class="docutils literal notranslate"><span class="pre">YAML</span> <span class="pre">format</span></code> and usually called <code class="docutils literal notranslate"><span class="pre">config.yml</span></code> and can be provided to Snakemake using the <code class="docutils literal notranslate"><span class="pre">--profile</span></code> flag (Note to only provide the path where Snakemake should look for the profile file, e.g. <code class="docutils literal notranslate"><span class="pre">profiles/slurm/</span></code> (without the profile filename)). An option defined by <code class="docutils literal notranslate"><span class="pre">--someoption</span></code> in the Snakemake command line call becomes <code class="docutils literal notranslate"><span class="pre">someoption:</span> </code> in the profile. Example profile:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jobs</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">default</span><span class="o">-</span><span class="n">resources</span><span class="p">:</span> 
  <span class="n">slurm_account</span><span class="p">:</span> <span class="n">project_xxx</span>
</pre></div>
</div>
<p>Check out another <a class="reference external" href="https://coderefinery.github.io/TTT4HPC_parallel_workflows/parallelization/parallelize_using_workflow_manager/#create-and-run-snakemake-workflow">Snakemake profile example from the Tuesdays Tools and Techniques course</a>.</p>
</section>
<section id="good-practices">
<h3>Good practices<a class="headerlink" href="#good-practices" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>General:</p>
<ul>
<li><p>As with all code, it is advised to also keep your Snakefiles under <strong>version control</strong>, e.g. using <code class="docutils literal notranslate"><span class="pre">git</span></code></p></li>
<li><p>Consider <strong>containerizing</strong> your whole workflow for portability</p></li>
</ul>
</li>
<li><p>When running Snakemake on clusters:</p>
<ul>
<li><p>Try to <strong>avoid unnecessary read and write operations</strong>, check if use of fast local disk is possible</p></li>
<li><p>Consider summarizing small jobs/job steps into one job  when you want to use the SLURM plugin to limit SLURM accounting overhead, e.g. by <a class="reference external" href="https://snakemake.readthedocs.io/en/stable/executing/grouping.html">job grouping</a></p></li>
<li><p>Try to avoid creating a lot of files, especially in the same folder, <a class="reference external" href="https://snakemake.readthedocs.io/en/stable/snakefiles/rules.html#protected-and-temporary-files">Snakemake can remove temporary files after the job is finnished</a>.</p></li>
</ul>
</li>
</ul>
</section>
<section id="cluster-specific-information">
<h3>Cluster specific information<a class="headerlink" href="#cluster-specific-information" title="Link to this heading"></a></h3>
<section id="csc-puhti-or-lumi">
<h4>CSC Puhti or LUMI<a class="headerlink" href="#csc-puhti-or-lumi" title="Link to this heading"></a></h4>
<p><a class="reference external" href="https://a3s.fi/CSC_training/snakemake_hackathon.html#/snakemake-hackathon-in-csc-supercomputers">Slides on running Snakemake on CSC’s Puhti or LUMI</a>.</p>
<div class="admonition-keypoints keypoints admonition" id="keypoints-0">
<p class="admonition-title">Keypoints</p>
<ul class="simple">
<li><p>Use the <code class="docutils literal notranslate"><span class="pre">snakemake</span> <span class="pre">module</span></code> if your cluster provides one; add own packages or modules where necessary</p></li>
<li><p>If that fails, consider creating your own environment; follow cluster specific instructions</p></li>
<li><p>Use interactive jobs to test and setup your Snakemake workflow</p></li>
<li><p>Use normal batch jobs for running your tested workflows via sbatch script or using the Snakemake SLURM executor (<code class="docutils literal notranslate"><span class="pre">--jobs</span> <span class="pre">=</span> <span class="pre">1</span></code>)</p></li>
<li><p>Use Hyperqueue to scale your workflow on the cluster, especially when you need multiple nodes</p></li>
</ul>
</div>
</section>
</section>
</section>
<span id="document-Hackathon"></span><section id="hackathon">
<h2>Hackathon<a class="headerlink" href="#hackathon" title="Link to this heading"></a></h2>
<p>This time is reserved for you. You can start implementing your own workflow with Snakemake, move your existing workflow to a cluster or follow any of our toy examples, based on interest.</p>
<section id="snakemake-in-general-and-on-cluster">
<h3>Snakemake in general and on cluster<a class="headerlink" href="#snakemake-in-general-and-on-cluster" title="Link to this heading"></a></h3>
<p>If you have not used Snakemake before, we recommend to start on your laptop and follow the <a class="reference external" href="https://coderefinery.github.io/reproducible-research/workflow-management/#a-demo">CodeRefinery Snakemake demo</a> instructions to create your first workflow and run it on your laptop (Installation: <a class="reference external" href="https://snakemake.readthedocs.io/en/stable/getting_started/installation.html">Snakemake installation</a>) or within an interactive job on your cluster (resource needs are minimal, 2GB of memory and one core should more than suffice).</p>
<p>You can also use the CodeRefinery example as a base and try and run it on a cluster as batch job or with Hyperqueue instead.</p>
</section>
<section id="using-hyperqueue">
<h3>Using Hyperqueue<a class="headerlink" href="#using-hyperqueue" title="Link to this heading"></a></h3>
<p>If you want to try out Hyperqueue, we suggest to follow the <a class="reference internal" href="#document-Hyperqueue_example"><span class="std std-doc">Hyperqueue example</span></a>.</p>
</section>
</section>
</div>
<div class="toctree-wrapper compound">
</div>
<section id="about-the-course">
<span id="learner-personas"></span><h2>About the course<a class="headerlink" href="#about-the-course" title="Link to this heading"></a></h2>
<p>Snakemake is a common entry tool in the world of computational workflows, especially in Bioinformatics.</p>
<p>The tool is designed to support you in setting up a workflow system, which opposed to a “your favorite language here” script, helps you keep track of your processes.</p>
<p>For Snakemake, the user has to define inputs and outputs and the tool will figure out the order of steps and which steps can be run in parallel.</p>
<p>This Hackathon is open for all, free of charge and independent of field of Science and it is all about getting your own workflows to the supercomputer (Puhti, Mahti, Lumi or other).</p>
</section>
<section id="content">
<h2>Content<a class="headerlink" href="#content" title="Link to this heading"></a></h2>
<p>We will offer short introduction to snakemake and a supercomputing concepts refresher session in the beginning, which you can attend if needed.</p>
<p>Then we will talk about opportunities and challenges with moving workflows from laptop to the supercomputer and give tips on how to go about it.</p>
<p>The afternoon is reserved for your own work. You can either work on your own “Snakefile”, moving your workflow from laptop to supercomputer or work on our toy example, to help understand the concepts better before moving to your own work.</p>
</section>
<section id="learning-outcomes">
<h2>Learning outcomes<a class="headerlink" href="#learning-outcomes" title="Link to this heading"></a></h2>
<p>After this course, participants will be able to…</p>
<ul class="simple">
<li><p>Understand what is snakemake</p></li>
<li><p>Decide if using Snakemake fits their workflow</p></li>
<li><p>Implement own workflow with Snakemake</p></li>
<li><p>Move own workflow to the supercomputer</p></li>
</ul>
</section>
<section id="see-also">
<h2>See also<a class="headerlink" href="#see-also" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://a3s.fi/swift/v1/AUTH_53f5b0ae8e724b439a4cd16d1237015f/csc-training/workflows_workshop.html">CSC bio workflows with Nextflow course materials</a></p></li>
<li><p><a class="reference external" href="https://a3s.fi/2001659-workflow-workshop/workflows.html#/">CSC workflows on HPC considerations - slides</a></p></li>
<li><p><a class="reference external" href="https://docs.csc.fi/computing/running/throughput/">CSC High Throughput Computing docs page</a></p></li>
<li><p><a class="reference external" href="https://github.com/NBISweden/workshop-snakemake-byoc">Uppsala snakemake BYOC</a></p></li>
<li><p><a class="reference external" href="https://slides.com/johanneskoester/snakemake-tutorial">Snakemake tutorial</a></p></li>
<li><p><a class="reference external" href="https://coderefinery.github.io/reproducible-research/workflow-management/">CodeRefinery lesson</a></p></li>
<li><p><a class="reference external" href="https://carpentries-incubator.github.io/workflows-snakemake/">Carpentries lesson</a></p></li>
<li><p><a class="reference external" href="https://snakemake.github.io/snakemake-workflow-catalog/">Snakemake workflows catalog</a></p></li>
<li><p><a class="reference external" href="https://docs.csc.fi/support/tutorials/snakemake-puhti/">CSC Snakemake tutorial</a></p></li>
<li><p><a class="reference external" href="https://ocaisa.github.io/hpc-workflows/">MultiXScale Workflows material</a></p></li>
<li><p><a class="reference external" href="https://github.com/UNIVERSE-HPC/course-material/tree/main/technology_and_tooling%2Fsnakemake">Universe HPC Snakemake lesson</a></p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>